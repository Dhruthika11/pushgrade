# -*- coding: utf-8 -*-
"""assignment_1_5_6_7_8_9

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1clrq7mkd4Dr9LSP6KjjXy8ZtciYbOTJC

#assignment1
"""

num = 5
if num > 0:
    print("Positive number")
elif num == 0:
    print("Zero")
else:
    print("Negative number")

# Assignment 1: Python Syntax and Data Types - Part B

# 1. Numeric Types
a = 10             # Integer
b = 3.14           # Float
c = 2 + 3j         # Complex number

print("Numeric Types:")
print(type(a))     # <class 'int'>
print(type(b))     # <class 'float'>
print(type(c))     # <class 'complex'>
print()

# 2. Strings
name = "Aarav"
print("String Operations:")
print(name.upper())         # AARAV
print(name.lower())         # aarav
print(len(name))            # 5

text = "I am a student at IIT Gandhinagar in Gujarat"
print(text[0])              # 'C'
print(text[-1])             # 'r'
print(text[7:14])           # 'Connect'
print(text + " is awesome!")  # Concatenation
print("Hi! " * 3)           # Repetition
print(text.find("IIT"))     # Index of 'IIT'
print(text.replace("Connect", "Hub"))  # Replace
words = text.split()
print(words)                # Split into words
joined = "-".join(words)
print(joined)               # Join with '-'
print()

#  3. Booleans
is_student = True
print("Boolean Check:")
if is_student:
    print("hey student!")
print()

#  4. Lists
fruits = ['apple', 'banana', 'cherry', 'date']

# 1. Accessing elements
print(fruits[0])            # Output: 'apple'
print(fruits[-1])           # Output: 'date'

# 2. Slicing
print(fruits[1:3])          # Output: ['banana', 'cherry']

# 3. Adding elements
fruits.append('elderberry')         # Adds to end
fruits.insert(1, 'blueberry')       # Inserts at index 1

# 4. Removing elements
fruits.remove('banana')             # Removes first occurrence
removed = fruits.pop()              # Removes and returns last item
print("Popped:", removed)

# 5. Updating elements
fruits[0] = 'apricot'               # Replaces 'apple' with 'apricot'

# 6. Length of list
print(len(fruits))                  # Output: number of elements

# 7. Sorting
fruits.sort()                       # Sorts alphabetically
print("Sorted list:", fruits)

# 8. Reversing
fruits.reverse()
print("Reversed list:", fruits)

# 9. Membership test
print('cherry' in fruits)           # Output: True or False

# 10. Looping through a list
for fruit in fruits:
    print(fruit)

# 11. Copying a list
fruits_copy = fruits.copy()

# 12. Clearing the list
fruits_copy.clear()

# 13. Concatenation and repetition
new_list = fruits + ['fig', 'grape']
repeated_list = fruits * 2

# Display final results
print("Final list:", fruits)
print("New list:", new_list)
print("Repeated list:", repeated_list)

# 5. Tuple Usage
birth_info = ("Noember", 2005)
print("Tuple Basics:")
print("Birth Month:", birth_info[0])
print("Birth Year:", birth_info[1])

colors = ('red', 'green', 'blue', 'green')
print(colors[1])              # Indexing
print(colors[0:2])            # Slicing
print(colors.count('green')) # Count
print(colors.index('blue'))  # Index of item
print(len(colors))           # Length

nested = (1, (2, 3), (4, 5))
print(nested[1][1])          # Nested tuple access

x, y, z, w = 'a', 'b', 'c', 'd'
print(x, y, z, w)            # Tuple unpacking
print()

# 6. Dictionaries
# Initial dictionary
profile = {
    'name': 'Aarav',
    'age': 21,
    'language': 'Python'
}

print("Original Dictionary:")
print(profile)

# 1. Accessing keys and values
print("Keys:", profile.keys())         # dict_keys(['name', 'age', 'language'])
print("Values:", profile.values())     # dict_values(['Aarav', 21, 'Python'])

# 2. Accessing items
print("Items:", profile.items())       # dict_items([('name', 'Aarav'), ('age', 21), ...])

# 3. Adding a new key-value pair
profile['university'] = 'IIT Gandhinagar'
print("After adding university:", profile)

# 4. Updating an existing value
profile['age'] = 22
print("After updating age:", profile)

# 5. Using get() method (safe access)
print("City:", profile.get('city', 'Not specified'))  # Returns default if key not found

# 6. Removing a key-value pair
profile.pop('language')
print("After removing 'language':", profile)

# 7. Checking if key exists
if 'name' in profile:
    print("Name is present in profile")

# 8. Copying a dictionary
profile_copy = profile.copy()
print("Copied Dictionary:", profile_copy)

# 9. Merging dictionaries
extra_info = {'gender': 'Male', 'hobbies': ['coding', 'reading']}
profile.update(extra_info)
print("After merging extra info:", profile)

# 10. Clearing a dictionary
profile_copy.clear()
print("Cleared copy:", profile_copy)

"""#assignment5"""

def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32

try:
    temp_str = input("Enter temperature in Celsius: ")
    celsius = float(temp_str)  # May raise ValueError
    fahrenheit = celsius_to_fahrenheit(celsius)
except ValueError:
    print("Invalid input. Please enter a valid number.")
else:
    print(f"Temperature in Fahrenheit: {fahrenheit}")
    try:
        with open("temperature_log.txt", "a") as file:
            file.write(f"{celsius}C = {fahrenheit}F\n")
    except IOError:
        print("Could not write to log file.")
finally:
    print("Temperature conversion process completed.")

try:
    temp_str = input("Enter temperature in Celsius: ")
    celsius = float(temp_str)  # May raise ValueError
    fahrenheit = celsius_to_fahrenheit(celsius)
except ValueError:
    print("Invalid input. Please enter a valid number.")
else:
    print(f"Temperature in Fahrenheit: {fahrenheit}")
    try:
        with open("temperature_log.txt", "a") as file:
            file.write(f"{celsius}C = {fahrenheit}F\n")
    except IOError:
        print("Could not write to log file.")
finally:
    print("Temperature conversion process completed.")

class InsufficientFundsError(Exception):
    """Custom exception for insufficient bank balance."""
    pass

def withdraw(balance, amount):
    if amount > balance:
        raise InsufficientFundsError(f"Cannot withdraw ${amount}. Balance is only ${balance}.")
    return balance - amount

try:
    balance = 1000
    amount = float(input("Enter amount to withdraw: "))
    new_balance = withdraw(balance, amount)
except ValueError:
    print("Invalid amount entered. Please enter a number.")
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")
else:
    print(f"Withdrawal successful. New balance: Rs{new_balance}")
finally:
    print("Transaction attempt completed.")

try:
    balance = 1000
    amount = float(input("Enter amount to withdraw: "))
    new_balance = withdraw(balance, amount)
except ValueError:
    print("Invalid amount entered. Please enter a number.")
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")
else:
    print(f"Withdrawal successful. New balance: ${new_balance}")
finally:
    print("Transaction attempt completed.")

try:
    balance = 1000
    amount = float(input("Enter amount to withdraw: "))
    new_balance = withdraw(balance, amount)
except ValueError:
    print("Invalid amount entered. Please enter a number.")
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")
else:
    print(f"Withdrawal successful. New balance: ${new_balance}")
finally:
    print("Transaction attempt completed.")

"""#assignment6"""

class Book:
    def __init__(self, title, author, year, available=True):
        self.title = title
        self.author = author
        self.year = year
        self.available = available

    def borrow(self):
        if self.available:
            self.available = False
            print(f"You have borrowed '{self.title}'.")
        else:
            print(f"Sorry, '{self.title}' is currently not available.")

    def return_book(self):
        if not self.available:
            self.available = True
            print(f"Thank you for returning '{self.title}'.")
        else:
            print(f"'{self.title}' was not borrowed.")

    def display_info(self):
        status = "Available" if self.available else "Not Available"
        print(f"Title: {self.title}\nAuthor: {self.author}\nYear: {self.year}\nStatus: {status}")

# --- Creating Objects ---
book1 = Book("1984", "George Orwell", 1949)
book2 = Book("To Kill a Mockingbird", "Harper Lee", 1960, available=False)

# --- Demonstrating Functionality ---
book1.display_info()
print("\n---\n")
book1.borrow()
print("\n---\n")
book1.return_book()
print("\n---\n")

book2.display_info()
print("\n---\n")
book2.borrow()  # Should show unavailable

"""#assignment7"""

def convert_temperature(func, temp_celsius):
    return func(temp_celsius)

def to_fahrenheit(c):
    return (c * 9/5) + 32

def to_kelvin(c):
    return c + 273.15

print(convert_temperature(to_fahrenheit, 25))
print(convert_temperature(to_kelvin, 25))

words = ["banana", "fig", "apple", "kiwi"]
# Sort by word length
words.sort(key=lambda word: len(word))
print(words)

def log_function_call(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function '{func.__name__}' with arguments {args}")
        result = func(*args, **kwargs)
        print(f"Function '{func.__name__}' returned {result}")
        return result
    return wrapper

@log_function_call
def multiply(x, y):
    return x * y

multiply(3, 4)

names = ["Alice", "Bob", "Charlie", "Diana"]
initials = [name[0] for name in names]
print(initials)

prices_0 = {"apple": 1, "banana": 0.5, "cherry": 2}
conversion_rate = 1.1
prices_1 = {item: round(price * conversion_rate, 2) for item, price in prices_0.items()}
print(prices_1)

sentence = "The quick brown fox jumps over the lazy dog"
vowels = {char.lower() for char in sentence if char.lower() in "aeiou"}
print(vowels)

"""#assignment8"""

import matplotlib.pyplot as plt

days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
city_a = [22, 24, 23, 26, 25]
city_b = [18, 20, 19, 21, 22]

fig, axs = plt.subplots(2, 1, figsize=(8, 6), sharex=True)

axs[0].plot(days, city_a, marker='o', color='blue', label='City A')
axs[0].set_title('City A Temperature')
axs[0].set_ylabel('Temp (°C)')
axs[0].legend()
axs[0].grid(True)

axs[1].plot(days, city_b, marker='s', color='green', label='City B')
axs[1].set_title('City B Temperature')
axs[1].set_ylabel('Temp (°C)')
axs[1].legend()
axs[1].grid(True)

plt.xlabel('Day of Week')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

data = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

plt.imshow(data, cmap='viridis', interpolation='nearest')

plt.colorbar()

plt.title("Heatmap")
plt.xlabel("Columns")
plt.ylabel("Rows")

plt.show()

import pandas as pd
import matplotlib.pyplot as plt

data = {
    'Math': [90, 85, 78, 92, 88],
    'Science': [84, 89, 85, 90, 86],
    'English': [78, 81, 86, 75, 80],
    'History': [70, 75, 80, 68, 72]
}

df = pd.DataFrame(data)

df

import pandas as pd

# DataFrame 1: Student info
students_df = pd.DataFrame({
    'StudentID': [101, 102, 103, 104],
    'Name': ['Alice', 'Bob', 'Charlie', 'Diana']
})

# DataFrame 2: Test scores
scores_df = pd.DataFrame({
    'StudentID': [101, 102, 104, 105],
    'Score': [88, 92, 79, 85]
})

# Merge the DataFrames on 'StudentID'
merged_df = pd.merge(students_df, scores_df, on='StudentID', how='outer')

print("Merged DataFrame:")
print(merged_df)

import numpy as np

np.random.seed(0)  # For reproducibility
scores = np.random.randint(60, 101, size=(10, 3))  # Scores between 60 and 100

# Column labels for clarity
subjects = ['Math', 'Science', 'English']

print("Original Scores:\n", scores)
print("\n---\n")

# 1. Mean score per student
student_averages = np.mean(scores, axis=1)
print("\nAverage Score per Student:\n", student_averages)
print("\n---\n")

# 2. Mean score per subject
subject_averages = np.mean(scores, axis=0)
print("\nAverage Score per Subject:\n", dict(zip(subjects, subject_averages)))
print("\n---\n")

# 3. Standard deviation across all scores
overall_std = np.std(scores)
print("\nOverall Standard Deviation of Scores:", overall_std)
print("\n---\n")

# 4. Find students who scored above 90 in all subjects
high_achievers = np.all(scores > 90, axis=1)
print("\nStudents who scored above 90 in all subjects:\n", high_achievers)
print("\n---\n")

# 5. Normalize scores (0 to 1 scale)
min_score = np.min(scores)
max_score = np.max(scores)
normalized_scores = (scores - min_score) / (max_score - min_score)
print("\nNormalized Scores (0 to 1):\n", normalized_scores.round(2))

"""#assignment9"""

# func.py from assignment2

def average(a, b):
    """Returns the average of two numbers."""
    return (a + b) / 2

def fourth_power(x):
    """Returns the fourth power of the input number."""
    return x ** 4

def format_name(first, last):
    """Returns a properly formatted full name."""
    return f"{first.strip().title()} {last.strip().title()}"

import unittest

class TestFunctions(unittest.TestCase):

    def test_average(self):
        self.assertEqual(average(4, 6), 5)
        self.assertEqual(average(-10, 10), 0)
        self.assertEqual(average(0, 0), 0)
        self.assertAlmostEqual(average(3.5, 2.5), 3.0)

    def test_fourth_power(self):
        self.assertEqual(fourth_power(2), 16)
        self.assertEqual(fourth_power(-2), 16)
        self.assertEqual(fourth_power(0), 0)
        self.assertAlmostEqual(fourth_power(1.5), 5.0625)

    def test_format_name(self):
        self.assertEqual(format_name("john", "doe"), "John Doe")
        self.assertEqual(format_name("  ALICE", "SMITH  "), "Alice Smith")
        self.assertEqual(format_name("", "brown"), " Brown")
        self.assertEqual(format_name("sAm", "o'nEiL"), "Sam O'Neil")

    def test_combined_usage(self):
        name = format_name(" alice ", " cooper ")
        avg = average(80, 90)
        score_boosted = fourth_power(10)
        self.assertEqual(name, "Alice Cooper")
        self.assertEqual(avg, 85)
        self.assertEqual(score_boosted, 10000)

# Run the tests
unittest.main(argv=[''], verbosity=2, exit=False)